BEGIN TRANSACTION;
CREATE TABLE libs (
	id INTEGER NOT NULL, 
	user_id INTEGER, 
	readme TEXT, 
	lib TEXT, 
	name VARCHAR(128), 
	description TEXT, 
	version VARCHAR(32), 
	license VARCHAR(128), 
	tags TEXT, 
	PRIMARY KEY (id)
);
INSERT INTO "libs" VALUES(1,1,'# controller\n\nRead from the game controllers\n\n## Explanation\n\nThe keypress state of the NES controllers are read in serially, bit-by-bit, using a shift register.\n\nThe shift register must be latched (brought high and then low) by writing to $4016, and then reading from $4016 for controller 1 and $4017 for controller 2.\n\nThis library reads that data into a single variable for `controller1` and `controller2`.\n\n## Variables\n\n1 byte in the zeropage should be assigned to `controller1`\nOptionally, an additional byte in the zeropage should be assigned to `controller2`\n\nTo set the number of controllers to read, define the `CONTROLLER_COUNT` constant as 1 or 2\n\n## Methods\n\n`controller1_read` - Read controller 1\n`controller2_read` - Read controller 2\n\n## Example\n\n```\nCONTROLLER_COUNT = 2\n\n;;;;;;;;\n\n.rsset $0000\n\ncontroller1 .rs 1\ncontroller2 .rs 1\n\n;;;;;;;;\n\n.include <controller.asm>\n\n;;;;;;;;\n\n    JSR controller1_read\n\n    LDA <controller1\n    LDA <controller2\n```\n\n','.ifndef CONTROLLER_COUNT ; 1 controller by default\nCONTROLLER_COUNT = 1\n.endif\n\n    JMP controller_guard\n\n.if CONTROLLER_COUNT >= 1 ; if 1 or more controllers\n\n.ifndef controller1\n    .out "Please reserve 1 byte in the zeropage for a `controller1` variable"\n.endif\n\ncontroller1_read:\n    ; latch controller\n    LDA #$01\n    STA $4016\n    LDA #$00\n    STA $4016\n\n    LDX #$08\ncontroller1_loop:\n    LDA $4016        ; read controller 1 keypress\n    LSR A            ; shift keypress into carry\n    ROL <controller1 ; rotate carry into controller1\n    DEX\n    BNE controller1_loop ; loop through the rest of the buttons\n\n    RTS\n\n.endif\n\n;;;;;;;;\n\n.if CONTROLLER_COUNT == 2 ; if 2 controllers\n\n.ifndef controller2\n    .out "Please reserve 1 byte in the zeropage for a `controller2` variable"\n.endif\n\ncontroller2_read:\n    ; latch controller\n    LDA #$01\n    STA $4016\n    LDA #$00\n    STA $4016\n\n    LDX #$08\ncontroller2_loop:\n    LDA $4017        ; read controller 2 keypress\n    LSR A            ; shift keypress into carry\n    ROL <controller2 ; rotate carry into controller2\n    DEX\n    BNE controller2_loop ; loop through the rest of the buttons\n\n    RTS\n\n.endif\n\ncontroller_guard:\n\n','controller','Read from the game controllers','1.0.1','GPLv3','controller,keypad,controls,input');
INSERT INTO "libs" VALUES(2,1,'# prng\n\nPseudo-random number generator\n\n## Explanation\n\nThis library utilizes a linear feedback shift register to generate a 16-bit pseudo-random number.\n\nRead more about it here: https://wiki.nesdev.com/w/index.php/Random_number_generator\n\n## Variables\n\n2 bytes in the zeropage should be assigned to `prng_seed`\n\nThis variable should be initialized to any value except $00.\n\n## Methods\n\n`prng` - Generate new pseudo-random value (should be called once per frame)\n`prng_byte` - Load pseudo-random value into A register\n\n## Example\n\n```\n.rsset $0000\n\nprng_seed .rs 2\n\n;;;;;;;;\n\n.include <prng.h>\n\n;;;;;;;;\n\n    ; initialize seed\n    LDA #$13\n    STA seed\n    LDA #$37\n    STA seed+1\n\n    ; run prng\n    JSR prng\n\n    ; load pseudo-random byte into A register\n    JSR prng_byte\n\n    ; save value\n    STA <$12\n```\n\n','.ifndef prng_seed\n    .out "Please reserve 2 bytes in the zeropage for a `prng_seed` variable"\n.endif\n\n    JMP prng_guard\n\nprng:\n    ; save registers\n    PHA\n    TXA\n    PHA\n\n    LDX #$08\n    LDA <prng_seed\n\n    ; loop 8 times\nprng_loop:\n    ASL A\n    ROL <prng_seed+1\n    BCC prng_skip\n    EOR #$2D\nprng_skip:\n    DEX\n    BNE prng_loop\n    STA <prng_seed\n\n    PLA\n    TAX\n    PLA\n\n    RTS\n\n;;;;;;;;\n\nprng_byte:\n    LDA <prng_seed\n\n    RTS\n\nprng_guard:\n\n','prng','Pseudo-random number generator','1.0.1','GPLv3','random,rng,prng');
INSERT INTO "libs" VALUES(3,1,'# rle\n\nRun-length encoding (RLE) decoder\n\n## Explanation\n\n`rle` utilizes the run-length encoding used in many Konami games (Blades of Steel, Contra, etc). The format is:\n\n| Value | Meaning                                               |\n|-------|-------------------------------------------------------|\n| 00-80 | Read another byte, and write it to the output n times |\n| 81-FE | Copy n - 128 bytes from input to output               |\n| FF    | End of compressed data                                |\n\nThis library decompresses data and writes it directly to the `PPUDATA` ($2007) register. It is ideal for reading background data directly into video memory.\n\nRegisters clobbered: none\n\n## Variables\n\n2 bytes in the zeropage should be assigned to `rle_pointer`\n\n## Methods\n\n`rle` - Perform RLE decode\n\n## Example\n\n```\n.rsset $0000\n\nrle_pointer .rs 2\n\n;;;;;;;;\n\n.include <rle.asm>\n\n;;;;;;;;\n\n    ; set rle_pointer to data''s location\n    LDA #LOW(data)\n    STA rle_pointer\n    LDA #HIGH(data)\n    STA rle_pointer+1\n\n    ; perform RLE decode\n    JSR rle\n\n;;;;;;;;\n\ndata:\n    .db $04, $01, $84, $12, $34, $56, $78, $FF\n```\n\n','.ifndef rle_pointer\n    .out "Please reserve 2 bytes in the zeropage for a `rle_pointer` variable"\n.endif\n\n    JMP rle_guard\n\nrle:\n    ; save registers\n    PHA\n    TYA\n    PHA\n    TXA\n    PHA\n\n    LDY #$00\n\nrle_start:\n    ; load first byte\n    LDA [rle_pointer], Y\n\n    ; if 0xFF, rle is done\n    CMP #$FF\n    BEQ rle_done\n\n    ; if greater than 0x80, copy bytes directly\n    ; if less than or equal to 0x80, repeat next byte A times\n    CMP #$80\n    BCC rle_repeat\n\n    ; output byte string of length A\nrle_length:\n    AND #$7F\n    TAX\n    INY\n    BNE rle_length_loop\n    INC <rle_pointer+1\n\n    ; loop through bytes\nrle_length_loop:\n    LDA [rle_pointer], Y\n    STA $2007\n\n    INY\n    BNE rle_length_loop_continue\n    INC <rle_pointer+1\nrle_length_loop_continue:\n\n    DEX\n    BNE rle_length_loop\nrle_lenth_done:\n\n    ; read next byte\n    JMP rle_start\n\n    ; repeat next byte A number of times\nrle_repeat:\n    TAX\n    INY\n    BNE rle_repeat_continue\n    INC <rle_pointer+1\n\nrle_repeat_continue:\n    LDA [rle_pointer], Y\n\n    ; loop through bytes\nrle_repeat_loop:\n    STA $2007\n    DEX\n    BNE rle_repeat_loop\n\n    INY\n    BNE rle_repeat_done\n    INC <rle_pointer+1\nrle_repeat_done:\n\n    ; read next byte\n    JMP rle_start\n\nrle_done:\n    ; restore registers\n    PLA\n    TAX\n    PLA\n    TAY\n    PLA\n\n    RTS\n\nrle_guard:\n\n','rle','Run-length encoding (RLE) decoder','1.0.1','GPLv3','rle,encoding,decoding,compression');
CREATE TABLE users (
	id INTEGER NOT NULL, 
	name VARCHAR(128), 
	email VARCHAR(128), 
	password VARCHAR(128), 
	date_created DATETIME, 
	date_login DATETIME, 
	login_token VARCHAR(128), 
	PRIMARY KEY (id)
);
INSERT INTO "users" VALUES(1,'Kevin Selwyn','kevinselwyn@gmail.com','1a1dc91c907325c69271ddf0c944bc72','2017-03-14 10:29:03.225150','2017-03-17 10:04:56.231847',NULL);
COMMIT;
